{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/normalized_state.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.algorithms.normalized-state/integrate-ident","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/remove-ident","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","cljs.spec.alpha/def-impl","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl","cljs.spec.alpha/or-spec-impl","cljs.spec.alpha/cat-impl","map__78967","cljs.core/--destructure-map","retspec78964","cljs.core.get","argspec78963","com.fulcrologic.guardrails.core/run-check","f78966","G__78974","vec__78975","seq__78976","cljs.core/seq","first__78977","cljs.core/first","cljs.core/next","vec__78981","seq__78982","first__78983","ret78965","com.fulcrologic.fulcro.algorithms.normalized-state/tree-path->db-path","state","path","cljs.core/map?","cljs.core/vector?","h","t","new-path","np","cljs.core.conj","c","cljs.core.get_in","edn-query-language.core/ident?","cljs.core.not_EQ_","var_args","G__78996","com.fulcrologic.fulcro.algorithms.normalized-state/get-in-graph","js/Error","map__78997","argspec78986","retspec78987","f78989","ret78988","map__78998","cljs.core/ifn?","argspec78990","retspec78991","f78993","ret78992","state-map","cljs.core/any?","com.fulcrologic.fulcro.algorithms.normalized_state.get_in_graph","not-found","G__79000","com.fulcrologic.fulcro.algorithms.normalized-state/ui->props","this","com.fulcrologic.fulcro.algorithms.normalized_state.ui__GT_props","com.fulcrologic.fulcro.components/component->state-map","com.fulcrologic.fulcro.components/react-type","com.fulcrologic.fulcro.components/get-ident","component-class","ident","com.fulcrologic.fulcro.algorithms.denormalize/db->tree","com.fulcrologic.fulcro.components.get_query","p__79001","vec__79002","seq__79003","first__79004","com.fulcrologic.fulcro.algorithms.normalized-state/dissoc-in","m","k","ks","keys","temp__5802__auto__","nextmap","newmap","cljs.core.assoc","cljs.core.dissoc","cljs.spec.alpha.every_impl","G__79017","G__79019","com.fulcrologic.fulcro.algorithms.normalized-state/remove-entity","map__79020","argspec79009","retspec79010","f79012","ret79011","map__79021","G__79022","argspec79013","retspec79014","f79016","p1__79005#","or__5045__auto__","p1__79006#","p2__79007#","ret79015","com.fulcrologic.fulcro.algorithms.normalized_state.remove_entity","cascade","cljs.core/keyword?","cljs.core/set?","normalized-paths","ps","cljs.core/reduce-kv","v","paths*","cljs.core.filter","cljs.core/count","ident-specific-paths","a-path","vl","cljs.core/coll?","cljs.core/some","cljs.core._EQ_","remove-ident-at-path","a-normalized-path","cljs.core/every?","remove-ident-from-tables","cljs.core.reduce","state-without-entity","target-entity","cascaded-idents","table-key","cljs.core.map","entity-field","clojure.set.intersection","cljs.core/set","cljs.core/keys","final-state","edge","new-state","G__79035","G__79036","G__79038","com.fulcrologic.fulcro.algorithms.normalized-state/sort-idents-by","map__79039","G__79040","retspec79028","argspec79027","f79030","G__79041","ret79029","map__79042","G__79043","argspec79031","retspec79032","f79034","ret79033","vector-of-idents","sortkey-fn","comp-fn","kfn","cljs.core/vec","cljs.core.sort_by","com.fulcrologic.fulcro.algorithms.normalized_state.sort_idents_by","cljs.core/compare","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller!","p__79046","map__79047","seq79044","G__79045","self__5754__auto__","ref","args","cljs.core.apply","cljs.core/swap!","cljs.core/update-in","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller-in!","p__79051","map__79052","seq79048","G__79049","G__79050","mutation-env","cljs.core/deref","cljs.core.into","and__5043__auto__"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.normalized-state\n  \"Functions that can be used against a normalized Fulcro state database. This namespace also includes some handy aliases\n   to useful functions that work on normalized state from other namespaces.\"\n  #?(:cljs (:require-macros com.fulcrologic.fulcro.algorithms.normalized-state))\n  (:require\n    [clojure.set :as set]\n    [com.fulcrologic.fulcro.components :as comp]\n    [edn-query-language.core :as eql]\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]]\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.merge :as merge]))\n\n(def integrate-ident\n  \"[state ident & named-parameters]\n\n  Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  targeting/integrate-ident*)\n\n(def remove-ident\n  \" [state-map ident path-to-idents]\n\n  Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  merge/remove-ident*)\n\n\n(>defn tree-path->db-path\n  \"Convert a 'denormalized' path into a normalized one by walking the path in state treating ident-based edges\n  as jumps back to that location in state-map.\n\n  For example, one might find this to be true for a normalized db:\n\n  ```\n  state => {:person/id {1 {:person/id 1 :person/spouse [:person/id 3]}\n                        3 {:person/id 3 :person/first-name ...}}}\n\n  (tree-path->db-path state [:person/id 1 :person/spouse :person/first-name])\n  => [:person/id 3 :person/first-name]\n  ```\n  \"\n  ([state path]\n   [map? vector? => vector?]\n   (loop [[h & t] path\n          new-path []]\n     (if h\n       (let [np (conj new-path h)\n             c  (get-in state np)]\n         (if (eql/ident? c)\n           (recur t c)\n           (recur t (conj new-path h))))\n       (if (not= path new-path)\n         new-path\n         path)))))\n\n\n(>defn get-in-graph\n  \"Like clojure.core/get-in, but as it traverses the path it will follow idents in the state-map. This makes it similar\n   to a very targeted `db->tree`, but allows you to get something along a particular path without needing to parse a query.\n\n   Returns the data at the path, `not-found` (if specified) if nothing is found; otherwise nil.\n\n   See also `tree-path->db-path`.\"\n  ([state-map path]\n   [map? vector? => any?]\n   (get-in-graph state-map path nil))\n\n  ([state-map path not-found]\n   [map? vector? any? => any?]\n   (get-in state-map (tree-path->db-path state-map path) not-found)))\n\n\n(defn ui->props\n  \"Obtain a tree of props for a UI instance from the current application state. Useful in mutations where you want\n   to denormalize an entity from the state database. `this` can often be obtained from the mutation `env` at the\n  `:component` key.\"\n  ([this]\n   (ui->props (comp/component->state-map this) (comp/react-type this) (comp/get-ident this)))\n  ([state-map component-class ident]\n   (fdn/db->tree (comp/get-query component-class state-map) (get-in-graph state-map ident) state-map)))\n\n\n(defn dissoc-in\n  \"Dissociates an entry from a nested associative structure returning a new\n   nested structure. keys is a sequence of keys. Any empty maps that result\n   will not be present in the new structure.\n\n   The `ks` is *not* ident-aware. This function is here simply because it\n   is often needed, and clojure.core does not supply it.\n   \"\n  [m [k & ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n\n(>defn remove-entity\n  \"Remove the given entity at the given ident. Also scans all tables and removes any to-one or to-many idents that are\n  found that match `ident` (removes dangling pointers to the removed entity).\n\n  The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n  (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n  Returns the new state map with the entity(ies) removed.\"\n\n  ([state-map ident]\n   [map? eql/ident? => map?]\n   (remove-entity state-map ident #{}))\n\n  ([state-map ident cascade]\n   [map? eql/ident? (s/coll-of keyword? :kind set?) => map?]\n\n   (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n         normalized-paths         (letfn [(paths* [ps ks m]\n                                            (reduce-kv\n                                              (fn [ps k v]\n                                                (if (map? v)\n                                                  (paths* ps (conj ks k) v)\n                                                  (conj ps (conj ks k))))\n                                              ps\n                                              m))]\n                                    (filter #(< (count %) 4)\n                                      (paths* () [] state-map)))\n\n         ident-specific-paths     (fn [state ident]\n                                    (filter (fn [a-path]\n                                              (let [vl (get-in state a-path)]\n                                                (if (coll? vl)\n                                                  (or\n                                                    (some #{ident} vl)\n                                                    (= ident vl)))))\n                                      normalized-paths))\n\n         remove-ident-at-path     (fn [state a-normalized-path ident]\n                                    (let [v (get-in state a-normalized-path)]\n                                      (if (coll? v)\n                                        (cond\n                                          (= v ident) (dissoc-in state a-normalized-path)\n                                          (every? eql/ident? v) (merge/remove-ident* state ident a-normalized-path)\n                                          :else state)\n                                        state)))\n\n\n         remove-ident-from-tables (fn [state ident]\n                                    (reduce #(remove-ident-at-path %1 %2 ident)\n                                      state\n                                      (ident-specific-paths state ident)))\n\n         state-without-entity     (->\n                                    ;; remove pointers to the entity\n                                    (remove-ident-from-tables state-map ident)\n                                    ;; remove the top-level entity\n                                    (dissoc-in ident))\n\n         target-entity            (get-in-graph state-map ident)\n\n         ;; Computed set of all affected entities when cascade option is provided\n         cascaded-idents          (let [table-key (first ident)]\n                                    (map\n                                      (fn [entity-field]\n                                        (get-in state-map\n                                          (conj [table-key (table-key target-entity)] entity-field)))\n                                      (set/intersection\n                                        cascade\n                                        (set (keys target-entity)))))\n\n         final-state              (reduce\n                                    (fn [state edge]\n                                      (if (every? eql/ident? edge)\n                                        (reduce (fn [new-state ident] (remove-entity new-state ident cascade)) state edge)\n                                        (remove-entity state edge cascade)))\n                                    state-without-entity\n                                    cascaded-idents)]\n\n     final-state)))\n\n\n;; This one isn't quite right yet...hold off\n#_(>defn remove-edge\n    \"Remove the given edge at the given path. Also scans all tables and removes any to-one or to-many idents that are\n    found that match `edge` (removes dangling pointers to the removed entity(ies).\n\n    The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n    (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n    Returns the new state map with the entity(ies) removed.\"\n\n    ([state-map path-to-edge]\n     [map? vector? => any?]\n     (remove-edge state-map path-to-edge #{}))\n\n\n    ([state-map path-to-edge cascade]\n     [map? vector? (s/coll-of keyword? :kind set?) => map?]\n     (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n           normalized-paths (letfn [(paths* [ps ks m]\n                                      (reduce-kv\n                                        (fn [ps k v]\n                                          (if (map? v)\n                                            (paths* ps (conj ks k) v)\n                                            (conj ps (conj ks k))))\n                                        ps\n                                        m))]\n                              (filter #(< (count %) 4)\n                                (paths* () [] state-map)))\n\n           candidate        (let [vl (get-in state-map path-to-edge)]\n                              (if-not (vector? vl)\n                                nil\n                                (cond\n                                  (eql/ident? vl) [vl]\n                                  (every? eql/ident? vl) vl)))\n\n           final-state      (if (some #{path-to-edge} normalized-paths)\n                              (reduce\n                                #(remove-entity %1 %2 cascade)\n                                state-map\n                                candidate)\n                              state-map)]\n       final-state)))\n\n\n(>defn sort-idents-by\n  \"Returns the sorted version of the provided vector of idents.\n\n  Intended to be used as\n  ```\n  (sort-idents-by people-idents :person/name)\n  ```\n\n  NOTE: The order of parameters is different from clojure.core/sort-by to facilitate:\n\n  ```\n  (swap! state update-in [:person/id 1 :person/children]\n    (partial sort-idents-by @state) :person/first-name)\n\n  ```\n\n  You can optionally pass a `comp-fn` which is as-described in `sort-by`.\n  \"\n  ([state-map vector-of-idents sortkey-fn comp-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? ifn? => any?]\n   (let [kfn (fn [ident] (sortkey-fn (get-in state-map ident)))]\n     (vec (sort-by kfn comp-fn vector-of-idents))))\n  ([state-map vector-of-idents sortkey-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? => any?]\n   (sort-idents-by state-map vector-of-idents sortkey-fn compare)))\n\n\n(defn update-caller!\n  \"Runs clojure.core/update on the table entry in the state database that corresponds\n   to the mutation caller (which can be explicitly set via `:ref` when calling `transact!`).\n\n   Equivalent to\n   ```\n   (apply swap! (:state env) update-in (:ref env) ...)\n   ```\n   \"\n\n  [{:keys [state ref]} & args]\n  (apply swap! state update-in ref args))\n\n\n(defn update-caller-in!\n  \"Like swap! but starts at the ref from `env`, adds in supplied `path` elements\n  (resolving across idents if necessary). Finally runs an update-in on that resultant\n  path with the given `args`.\n\n   Equivalent to:\n   ```\n   (swap! (:state env) update-in (tree-path->db-path @state (into (:ref env) path)) args)\n   ```\n   with a small bit of additional sanity checking.\"\n\n  [{:keys [state ref] :as mutation-env} path & args]\n  (let [path (tree-path->db-path @state (into ref path))]\n    (if (and path (get-in-graph @state path))\n      (apply swap! state update-in path args)\n      @state)))\n\n#?(:clj\n   (defmacro swap!->\n     \"A useful macro for threading multiple operations together on an atom (e.g. state atom in mutation)\n\n     Equivalent to:\n     ```\n     (swap! atom (fn [s] (-> s ...forms...)))\n     ```\n\n     For example\n\n     ```\n     (swap!-> (:state env)\n       (merge/merge-component ...)\n       (integrate-ident* ...))\n     ```\n     \"\n     [atom & forms]\n     `(swap! ~atom (fn [s#] (-> s# ~@forms)))))\n"]}
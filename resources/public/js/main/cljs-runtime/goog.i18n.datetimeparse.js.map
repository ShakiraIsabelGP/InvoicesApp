{
"version":3,
"file":"goog.i18n.datetimeparse.js",
"lineCount":516,
"mappings":"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",
"sources":["goog/i18n/datetimeparse.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Date/Time parsing library with locale support.\n */\n\n\n/**\n * Namespace for locale date/time parsing functions\n */\ngoog.provide('goog.i18n.DateTimeParse');\n\ngoog.require('goog.asserts');\ngoog.require('goog.date');\ngoog.require('goog.i18n.DateTimeFormat');\ngoog.require('goog.i18n.DateTimeSymbols');\ngoog.requireType('goog.i18n.DateTimeSymbolsType');\n\n\n/**\n * DateTimeParse is for parsing date in a locale-sensitive manner. It allows\n * user to use any customized patterns to parse date-time string under certain\n * locale. Things varies across locales like month name, weekname, field\n * order, etc.\n *\n * This module is the counter-part of DateTimeFormat. They use the same\n * date/time pattern specification, which is borrowed from ICU/JDK.\n *\n * This implementation could parse partial date/time.\n *\n * Time Format Syntax: To specify the time format use a time pattern string.\n * In this pattern, following letters are reserved as pattern letters, which\n * are defined as the following:\n *\n * <pre>\n * Symbol   Meaning                 Presentation        Example\n * ------   -------                 ------------        -------\n * G        era designator          (Text)              AD\n * y#       year                    (Number)            1996\n * M        month in year           (Text & Number)     July & 07\n * d        day in month            (Number)            10\n * h        hour in am/pm (1~12)    (Number)            12\n * H        hour in day (0~23)      (Number)            0\n * m        minute in hour          (Number)            30\n * s        second in minute        (Number)            55\n * S        fractional second       (Number)            978\n * E        day of week             (Text)              Tuesday\n * D        day in year             (Number)            189\n * a        am/pm marker            (Text)              PM\n * k        hour in day (1~24)      (Number)            24\n * K        hour in am/pm (0~11)    (Number)            0\n * z        time zone               (Text)              Pacific Standard Time\n * Z        time zone (RFC 822)     (Number)            -0800\n * v        time zone (generic)     (Text)              Pacific Time\n * '        escape for text         (Delimiter)         'Date='\n * ''       single quote            (Literal)           'o''clock'\n * </pre>\n *\n * The count of pattern letters determine the format. <p>\n * (Text): 4 or more pattern letters--use full form,\n *         less than 4--use short or abbreviated form if one exists.\n *         In parsing, we will always try long format, then short. <p>\n * (Number): the minimum number of digits. <p>\n * (Text & Number): 3 or over, use text, otherwise use number. <p>\n * Any characters that not in the pattern will be treated as quoted text. For\n * instance, characters like ':', '.', ' ', '#' and '@' will appear in the\n * resulting time text even they are not embraced within single quotes. In our\n * current pattern usage, we didn't use up all letters. But those unused\n * letters are strongly discouraged to be used as quoted text without quote.\n * That's because we may use other letter for pattern in future. <p>\n *\n * Examples Using the US Locale:\n *\n * Format Pattern                         Result\n * --------------                         -------\n * \"yyyy.MM.dd G 'at' HH:mm:ss vvvv\" ->>  1996.07.10 AD at 15:08:56 Pacific Time\n * \"EEE, MMM d, ''yy\"                ->>  Wed, July 10, '96\n * \"h:mm a\"                          ->>  12:08 PM\n * \"hh 'o''clock' a, zzzz\"           ->>  12 o'clock PM, Pacific Daylight Time\n * \"K:mm a, vvv\"                     ->>  0:00 PM, PT\n * \"yyyyy.MMMMM.dd GGG hh:mm aaa\"    ->>  01996.July.10 AD 12:08 PM\n *\n * <p> When parsing a date string using the abbreviated year pattern (\"yy\"),\n * DateTimeParse must interpret the abbreviated year relative to some\n * century. It does this by adjusting dates to be within 80 years before and 20\n * years after the time the parse function is called. For example, using a\n * pattern of \"MM/dd/yy\" and a DateTimeParse instance created on Jan 1, 1997,\n * the string \"01/11/12\" would be interpreted as Jan 11, 2012 while the string\n * \"05/04/64\" would be interpreted as May 4, 1964. During parsing, only\n * strings consisting of exactly two digits, as defined by {@link\n * java.lang.Character#isDigit(char)}, will be parsed into the default\n * century. Any other numeric string, such as a one digit string, a three or\n * more digit string will be interpreted as its face value.\n *\n * <p> If the year pattern does not have exactly two 'y' characters, the year is\n * interpreted literally, regardless of the number of digits. So using the\n * pattern \"MM/dd/yyyy\", \"01/11/12\" parses to Jan 11, 12 A.D.\n *\n * <p> When numeric fields abut one another directly, with no intervening\n * delimiter characters, they constitute a run of abutting numeric fields. Such\n * runs are parsed specially. For example, the format \"HHmmss\" parses the input\n * text \"123456\" to 12:34:56, parses the input text \"12345\" to 1:23:45, and\n * fails to parse \"1234\". In other words, the leftmost field of the run is\n * flexible, while the others keep a fixed width. If the parse fails anywhere in\n * the run, then the leftmost field is shortened by one character, and the\n * entire run is parsed again. This is repeated until either the parse succeeds\n * or the leftmost field is one character in length. If the parse still fails at\n * that point, the parse of the run fails.\n *\n * <p> Now timezone parsing only support GMT:hhmm, GMT:+hhmm, GMT:-hhmm\n */\n\n/**\n * Components of patternParts_ object.\n * @private @typedef {{\n *    text: (string|undefined),\n *    count: (number),\n *    numeric: (boolean|undefined),\n *    abutStart: (boolean|undefined),\n * }}\n */\ngoog.i18n.DateTimeParse.PatternPart;\n\n\n/**\n * Construct a DateTimeParse based on current locale.\n * @param {string|number} pattern pattern specification or pattern type.\n * @param {!Object=} opt_dateTimeSymbols Optional symbols to use for this\n *     instance rather than the global symbols.\n * @constructor\n * @final\n */\ngoog.i18n.DateTimeParse = function(pattern, opt_dateTimeSymbols) {\n  'use strict';\n  goog.asserts.assert(\n      opt_dateTimeSymbols !== undefined ||\n          goog.i18n.DateTimeSymbols !== undefined,\n      'goog.i18n.DateTimeSymbols or explicit symbols must be defined');\n\n  /** @const @private {!Array<!goog.i18n.DateTimeParse.PatternPart>}; */\n  this.patternParts_ = [];\n\n  /**\n   * Data structure with all the locale info needed for date formatting.\n   * (day/month names, most common patterns, rules for week-end, etc.)\n   * @const @private {!goog.i18n.DateTimeSymbolsType}\n   */\n  this.dateTimeSymbols_ = /** @type {!goog.i18n.DateTimeSymbolsType} */ (\n      opt_dateTimeSymbols || goog.i18n.DateTimeSymbols);\n  if (typeof pattern == 'number') {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n\n\n/**\n * Number of years prior to now that the century used to\n * disambiguate two digit years will begin\n *\n * @type {number}\n */\ngoog.i18n.DateTimeParse.ambiguousYearCenturyStart = 80;\n\n\n/**\n * All acceptable pattern characters.\n * @private\n */\ngoog.i18n.DateTimeParse.PATTERN_CHARS_ = 'GyMdkHmsSEDahKzZvQL';\n\n\n/**\n * Pattern characters that specify numerical field.\n * @private\n */\ngoog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_ = 'MydhHmsSDkK';\n\n\n/**\n * Pattern characters supported by predictive parsing.\n * @private\n */\ngoog.i18n.DateTimeParse.PREDICTIVE_FORMAT_CHARS_ = 'ahHkKm';\n\n\n/**\n * Apply a pattern to this Parser. The pattern string will be parsed and saved\n * in \"compiled\" form.\n * Note: this method is somewhat similar to the pattern parsing method in\n *       datetimeformat. If you see something wrong here, you might want\n *       to check the other.\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyPattern_ = function(pattern) {\n  'use strict';\n  let inQuote = false;\n  let buf = '';\n\n  for (let i = 0; i < pattern.length; i++) {\n    const ch = pattern.charAt(i);\n\n    // handle space, add literal part (if exist), and add space part\n    if (ch == ' ') {\n      if (buf.length > 0) {\n        this.patternParts_.push(\n            {text: buf, count: 0, abutStart: false, numeric: false});\n        buf = '';\n      }\n      this.patternParts_.push(\n          {text: ' ', count: 0, abutStart: false, numeric: false});\n      while (i < pattern.length - 1 && pattern.charAt(i + 1) == ' ') {\n        i++;\n      }\n    } else if (inQuote) {\n      // inside quote, except '', just copy or exit\n      if (ch == '\\'') {\n        if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n          // quote appeared twice continuously, interpret as one quote.\n          buf += '\\'';\n          i++;\n        } else {\n          // exit quote\n          inQuote = false;\n        }\n      } else {\n        // literal\n        buf += ch;\n      }\n    } else if (goog.i18n.DateTimeParse.PATTERN_CHARS_.indexOf(ch) >= 0) {\n      // outside quote, it is a pattern char\n      if (buf.length > 0) {\n        this.patternParts_.push(\n            {text: buf, count: 0, abutStart: false, numeric: false});\n        buf = '';\n      }\n      const count = this.getNextCharCount_(pattern, i);\n      const numeric = this.isNumericField_(ch, count);\n      this.patternParts_.push(\n          {text: ch, count: count, abutStart: false, numeric: numeric});\n      i += count - 1;\n    } else if (ch == '\\'') {\n      // Two consecutive quotes is a quote literal, inside or outside of quotes.\n      if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n        buf += '\\'';\n        i++;\n      } else {\n        inQuote = true;\n      }\n    } else {\n      buf += ch;\n    }\n  }\n\n  if (buf.length > 0) {\n    this.patternParts_.push(\n        {text: buf, count: 0, abutStart: false, numeric: false});\n  }\n\n  this.markAbutStart_();\n};\n\n\n/**\n * Apply a predefined pattern to this Parser.\n * @param {number} formatType A constant used to identified the predefined\n *     pattern string stored in locale repository.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyStandardPattern_ = function(formatType) {\n  'use strict';\n  let pattern;\n  // formatType constants are in consecutive numbers. So it can be used to\n  // index array in following way.\n\n  // if type is out of range, default to medium date/time format.\n  if (formatType > goog.i18n.DateTimeFormat.Format.SHORT_DATETIME) {\n    formatType = goog.i18n.DateTimeFormat.Format.MEDIUM_DATETIME;\n  }\n\n  if (formatType < 4) {\n    pattern = this.dateTimeSymbols_.DATEFORMATS[formatType];\n  } else if (formatType < 8) {\n    pattern = this.dateTimeSymbols_.TIMEFORMATS[formatType - 4];\n  } else {\n    pattern = this.dateTimeSymbols_.DATETIMEFORMATS[formatType - 8];\n    pattern = pattern.replace(\n        '{1}', this.dateTimeSymbols_.DATEFORMATS[formatType - 8]);\n    pattern = pattern.replace(\n        '{0}', this.dateTimeSymbols_.TIMEFORMATS[formatType - 8]);\n  }\n  this.applyPattern_(pattern);\n};\n\n\n/**\n * Calculate character repeat count in pattern.\n *\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @param {number} start The position of pattern character.\n *\n * @return {number} Repeat count.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.getNextCharCount_ = function(pattern, start) {\n  'use strict';\n  const ch = pattern.charAt(start);\n  let next = start + 1;\n  while (next < pattern.length && pattern.charAt(next) == ch) {\n    next++;\n  }\n  return next - start;\n};\n\n\n/**\n * Identify the start of an abutting numeric fields' run. Taking pattern\n * \"HHmmss\" as an example. It will try to parse 2/2/2 characters of the input\n * text, then if that fails, 1/2/2. We only adjust the width of the leftmost\n * field; the others remain fixed. This allows \"123456\" => 12:34:56, but\n * \"12345\" => 1:23:45. Likewise, for the pattern \"yyyyMMdd\" we try 4/2/2,\n * 3/2/2, 2/2/2, and finally 1/2/2. The first field of connected numeric\n * fields will be marked as abutStart, its width can be reduced to accommodate\n * others.\n *\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.markAbutStart_ = function() {\n  'use strict';\n  // abut parts are continuous numeric parts. abutStart is the switch\n  // point from non-abut to abut\n  let abut = false;\n\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    if (this.patternParts_[i].numeric) {\n      // if next part is not following abut sequence, and is numeric\n      if (!abut && i + 1 < this.patternParts_.length &&\n          this.patternParts_[i + 1].numeric) {\n        abut = true;\n        this.patternParts_[i].abutStart = true;\n      }\n    } else {\n      abut = false;\n    }\n  }\n};\n\n\n/**\n * Check if the pattern part is a numeric field.\n *\n * @param {string} ch pattern character\n * @param {number} count pattern character count\n *\n * @return {boolean} true if the pattern part is numeric field.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.isNumericField_ = function(ch, count) {\n  'use strict';\n  if (count <= 0) {\n    return false;\n  }\n  const i = goog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_.indexOf(ch);\n  return i > 0 || i == 0 && count < 3;\n};\n\n\n/**\n * Assert this object's pattern supports predictive parsing.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.assertPatternSupportsPredictive_ =\n    function() {\n  'use strict';\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    const part = this.patternParts_[i];\n    if (part.count > 0 &&\n        (goog.i18n.DateTimeParse.PREDICTIVE_FORMAT_CHARS_.indexOf(\n             part.text.charAt(0)) < 0 ||\n         part.count > 2 || part.abutStart)) {\n      throw new Error(\n          `'predictive' parsing is not supported for symbol ` +\n          `'${part.text.charAt(0)}'.`);\n    }\n  }\n};\n\n\n/**\n * Parse the given string and fill parsed values into date object.\n *\n * The existing values of any temporal fields of `date` not parsed from `text`\n * are not directly changed, but may be affected by overflow. E.g. if a minutes\n * value of 70 is parsed, the implementation of `date` may increment the value\n * of its hours field by 1 while setting its minutes value to 10.\n *\n * @param {string} text The string being parsed.\n * @param {?goog.date.DateLike} date The Date object to hold the parsed date.\n * @param {!goog.i18n.DateTimeParse.ParseOptions=} options The options object.\n * @return {number} How many characters parser advanced.\n */\ngoog.i18n.DateTimeParse.prototype.parse = function(text, date, options) {\n  'use strict';\n  let predictive = false;\n  let validate = false;\n  if (options) {\n    predictive = options.predictive || false;\n    validate = options.validate || false;\n  }\n\n  if (predictive) {\n    this.assertPatternSupportsPredictive_();\n  }\n\n  const cal = new goog.i18n.DateTimeParse.MyDate_();\n  const parsePos = [0];\n\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    if (predictive && parsePos[0] >= text.length) {\n      break;\n    }\n\n    if (this.patternParts_[i].count == 0) {\n      // Handle literal pattern characters.\n      if (this.subParseLiteral_(\n              text, parsePos, this.patternParts_[i], predictive)) {\n        continue;\n      }\n      return 0;\n    }\n\n    if (this.patternParts_[i].abutStart) {\n      // Handle fields within a run of abutting numeric fields.\n      const partsParsed = this.subParseAbut_(text, parsePos, i, cal);\n      if (partsParsed <= 0) {\n        return 0;\n      }\n      i += partsParsed - 1;\n      continue;\n    }\n\n    // Handle non-numeric fields and non-abutting numeric fields.\n    if (!this.subParse_(\n            text, parsePos, this.patternParts_[i], 0, cal, predictive)) {\n      return 0;\n    }\n  }\n\n  // return progress\n  return cal.calcDate_(date, validate) ? parsePos[0] : 0;\n};\n\n\n/**\n * Parse the given string and fill info into date object. This version will\n * validate that the result is a valid date/time.\n * @param {string} text The string being parsed.\n * @param {?goog.date.DateLike} date The Date object to hold the parsed date.\n * @return {number} How many characters parser advanced.\n * @deprecated Use goog.i18n.DateTimeParse.parse with the validate option\n *     instead.\n */\ngoog.i18n.DateTimeParse.prototype.strictParse = function(text, date) {\n  'use strict';\n  return this.parse(text, date, {validate: true});\n};\n\n\n/**\n * Parse a run of abutting numeric pattern parts. Take the pattern \"HHmmss\" as\n * an example. We will try to parse 2/2/2 characters of the input text, then if\n * that fails, 1/2/2. We only adjust the width of the leftmost field; the others\n * remain fixed. This allows \"123456\" => 12:34:56, but \"12345\" => 1:23:45.\n * Likewise, for the pattern \"yyyyMMdd\" we try 4/2/2, 3/2/2, 2/2/2, and finally\n * 1/2/2.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {number} abutStart the index of the pattern part starting the run\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value\n *\n * @return {number} how many pattern parts the parser advanced\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseAbut_ = function(\n    text, pos, abutStart, cal) {\n  'use strict';\n  const start = pos[0];\n  let abutPass = 0;\n\n  let i;\n  for (i = abutStart; i < this.patternParts_.length; i++) {\n    if (this.patternParts_[i].count == 0) {\n      // Literal pattern parts end abutting runs of numeric fields. Non-numeric\n      // fields do not (possibly a bug or undocumented constraint).\n      break;\n    }\n    // If we are at the start of a run of abutting fields, then\n    // shorten this field in each pass. If we can't shorten\n    // this field any more, then the parse of this set of\n    // abutting numeric fields has failed.\n    let count = this.patternParts_[i].count;\n    if (i == abutStart) {\n      count -= abutPass;\n      abutPass++;\n      if (count == 0) {\n        // tried all possible width, fail now\n        return 0;\n      }\n    }\n\n    // Predictive parsing is not supported for abutting runs of numbers.\n    if (!this.subParse_(\n            text, pos, this.patternParts_[i], count, cal,\n            /* predictive= */ false)) {\n      // If the parse fails anywhere in the run, back up to the\n      // start of the run and retry.\n      i = abutStart - 1;\n      pos[0] = start;\n      continue;\n    }\n  }\n\n  return i - abutStart;\n};\n\n\n/**\n * Protected method that converts one field of the input string into a\n * numeric field value.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this field.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value.\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParse_ = function(\n    text, pos, part, digitCount, cal, predictive) {\n  'use strict';\n  this.skipSpace_(text, pos);\n\n  if (part.numeric && digitCount > 0) {\n    if ((pos[0] + digitCount) > text.length) {\n      return false;\n    }\n  }\n\n  switch (part.text.charAt(0)) {\n    case 'G':  // ERA\n      this.subParseString_(\n          text, pos, [this.dateTimeSymbols_.ERAS], function(value) {\n            cal.era = value;\n          });\n      return true;\n    case 'M':  // MONTH\n    case 'L':  // STANDALONEMONTH\n      return this.subParseMonth_(text, pos, digitCount, part, cal);\n    case 'E':  // DAY_OF_WEEK\n      // Handle both short and long forms. Try count == 4 first.\n      const weekdays =\n          [this.dateTimeSymbols_.WEEKDAYS, this.dateTimeSymbols_.SHORTWEEKDAYS];\n      return this.subParseString_(text, pos, weekdays, function(value) {\n        cal.dayOfWeek = value;\n      });\n    case 'a':  // AM_PM\n      const success = this.subParseString_(\n          text, pos, [this.dateTimeSymbols_.AMPMS], function(value) {\n            cal.ampm = value;\n          }, predictive);\n      return predictive ? success : true;\n    case 'y':  // YEAR\n      return this.subParseYear_(text, pos, part, digitCount, cal);\n    case 'Q':  // QUARTER\n      // Handle both short and long forms. Try count == 4 first.\n      const quarters =\n          [this.dateTimeSymbols_.QUARTERS, this.dateTimeSymbols_.SHORTQUARTERS];\n      return this.subParseString_(text, pos, quarters, function(value) {\n        cal.month = value * 3;  // First month of quarter.\n        cal.day = 1;\n      });\n    case 'd':  // DATE\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.day = value;\n      });\n      return true;\n    case 'S':  // FRACTIONAL_SECOND\n      return this.subParseFractionalSeconds_(text, pos, digitCount, cal);\n    case 'h':  // HOUR (1..12)\n    case 'K':  // HOUR (0..11)\n    case 'H':  // HOUR_OF_DAY (0..23)\n    case 'k':  // HOUR_OF_DAY (1..24)\n      {\n        const success =\n              this.subParseInt_(text, pos, part, digitCount, function(value) {\n                cal.hours =\n                    (part.text.charAt(0) === 'h' && value === 12) ? 0 : value;\n              }, predictive);\n        return predictive ? success : true;\n      }\n    case 'm':  // MINUTE\n      {\n        const success =\n              this.subParseInt_(text, pos, part, digitCount, function(value) {\n                cal.minutes = value;\n              }, predictive);\n        return predictive ? success : true;\n      }\n    case 's':  // SECOND\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.seconds = value;\n      });\n      return true;\n    case 'z':  // ZONE_OFFSET\n    case 'Z':  // TIMEZONE_RFC\n    case 'v':  // TIMEZONE_GENERIC\n      return this.subParseTimeZoneInGMT_(text, pos, cal);\n    default:\n      return false;\n  }\n};\n\n\n/**\n * Parse year field. Year field is special because\n * 1) two digit year need to be resolved.\n * 2) we allow year to take a sign.\n * 3) year field participate in abut processing.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this field.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseYear_ = function(\n    text, pos, part, digitCount, cal) {\n  'use strict';\n  const start = pos[0];\n  // This awkward implementation preserves an existing behavioral quirk.\n  // digitCount (for abutting patterns) is ignored for signed years.\n  let value = this.parseInt_(text, pos, digitCount);\n  if (value === null) {\n    value = this.parseInt_(text, pos, 0, /* allowSigned= */ true);\n  }\n  if (value === null) {\n    return false;\n  }\n\n  // only if 2 digit was actually parsed, and pattern say it has 2 digit.\n  if (value >= 0 && pos[0] - start == 2 && part.count == 2) {\n    cal.setTwoDigitYear_(value);\n  } else {\n    cal.year = value;\n  }\n  return true;\n};\n\n\n/**\n * Parse Month field.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if parsing successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseMonth_ = function(\n    text, pos, digitCount, part, cal) {\n  'use strict';\n  if (part.numeric &&\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.month = value - 1;\n      })) {\n    return true;\n  }\n\n  // month is symbols, i.e., MMM, MMMM, LLL or LLLL\n  // Handle both short and long forms. Try count == 4 first.\n  const months = [\n    this.dateTimeSymbols_.MONTHS, this.dateTimeSymbols_.STANDALONEMONTHS,\n    this.dateTimeSymbols_.SHORTMONTHS,\n    this.dateTimeSymbols_.STANDALONESHORTMONTHS\n  ];\n  return this.subParseString_(text, pos, months, function(value) {\n    cal.month = value;\n  });\n};\n\n\n/**\n * Parse fractional seconds field.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos current parse position.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_ = function(\n    text, pos, digitCount, cal) {\n  'use strict';\n  const start = pos[0];\n  const value = this.parseInt_(text, pos, digitCount);\n  if (value === null) {\n    return false;\n  }\n  // Fractional seconds left-justify\n  const len = pos[0] - start;\n  cal.milliseconds = len < 3 ? value * Math.pow(10, 3 - len) :\n                               Math.round(value / Math.pow(10, len - 3));\n  return true;\n};\n\n\n/**\n * Parse GMT type timezone.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseTimeZoneInGMT_ = function(\n    text, pos, cal) {\n  'use strict';\n  // First try to parse generic forms such as GMT-07:00. Do this first\n  // in case localized DateFormatZoneData contains the string \"GMT\"\n  // for a zone; in that case, we don't want to match the first three\n  // characters of GMT+/-HH:MM etc.\n\n  // For time zones that have no known names, look for strings\n  // of the form:\n  //    GMT[+-]hours:minutes or\n  //    GMT[+-]hhmm or\n  //    GMT.\n  if (text.indexOf('GMT', pos[0]) == pos[0]) {\n    pos[0] += 3;  // 3 is the length of GMT\n  }\n\n  // TODO(user): check for named time zones by looking through the locale\n  // data from the DateFormatZoneData strings. Should parse both short and long\n  // forms.\n  // subParseZoneString(text, start, cal);\n\n  // As a last resort, look for numeric timezones of the form\n  // [+-]hhmm as specified by RFC 822.  This code is actually\n  // a little more permissive than RFC 822.  It will try to do\n  // its best with numbers that aren't strictly 4 digits long.\n\n  if (pos[0] >= text.length) {\n    cal.tzOffset = 0;\n    return true;\n  }\n\n  // Look for hours:minutes or hhmm.\n  const start = pos[0];\n  let value =\n      this.parseInt_(text, pos, /* digitCount= */ 0, /* allowSigned= */ true);\n  if (value === null) {\n    return false;\n  }\n\n  let offset;\n  if (pos[0] < text.length && text.charAt(pos[0]) == ':') {\n    // This is the hours:minutes case\n    offset = value * 60;\n    pos[0]++;\n    value = this.parseInt_(text, pos, /* digitCount= */ 0);\n    if (value === null) {\n      return false;\n    }\n    offset += value;\n  } else {\n    // This is the hhmm case.\n    offset = value;\n    // Assume \"-23\"..\"+23\" refers to hours.\n    if (offset < 24 && (pos[0] - start) <= 3) {\n      offset *= 60;\n    } else {\n      // todo: this looks questionable, should have more error checking\n      offset = offset % 100 + offset / 100 * 60;\n    }\n  }\n\n  cal.tzOffset = -offset;\n  return true;\n};\n\n\n/**\n * Parse unsigned integer pattern characters. These are symbols such as 'd' for\n * date.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this field.\n * @param {number} maxChars when > 0, at most this many characters are parsed.\n * @param {function(number)} callback function to record the parsed value.\n * @param {boolean=} predictive whether to apply predictive parsing rules.\n *     defaults to false\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseInt_ = function(\n    text, pos, part, maxChars, callback, predictive) {\n  'use strict';\n  predictive = predictive || false;\n  const start = pos[0];\n  let value = this.parseInt_(text, pos, maxChars);\n  if (value === null) {\n    return false;\n  } else if (predictive && pos[0] - start < part.count) {\n    if (pos[0] < text.length) {\n      return false;\n    }\n    // Infer trailing 0s to match pattern length.\n    value *= Math.pow(10, part.count - (pos[0] - start));\n  }\n  callback(value);\n  return true;\n};\n\n\n/**\n * Parse string pattern characters. These are symbols matching a set of strings\n * such as 'E' for day of week.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!Array<!Array<string>>} data Arrays of strings to match against,\n *     sequentially.\n * @param {function(number)} callback function to record the parsed value.\n * @param {boolean=} predictive whether to apply predictive parsing rules.\n *     defaults to false\n *\n * @return {boolean} True iff the input matches any of the strings in the data\n *     arrays.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseString_ = function(\n    text, pos, data, callback, predictive) {\n  'use strict';\n  predictive = predictive || false;\n  let value = null;\n  for (let i = 0; i < data.length; i++) {\n    value = this.matchString_(text, pos, data[i], predictive);\n    if (value !== null) {\n      callback(value);\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Parse literal pattern characters. These are any quoted characters and non-\n * alphabetic unquoted characters.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseLiteral_ = function(\n    text, pos, part, predictive) {\n  'use strict';\n  // A run of white space in the pattern matches a run\n  // of white space in the input text.\n  if (part.text.charAt(0) == ' ') {\n    // Advance over run in input text\n    const start = pos[0];\n    this.skipSpace_(text, pos);\n\n    // Must see at least one white space char in input\n    if (pos[0] > start) {\n      return true;\n    }\n  } else if (text.indexOf(part.text, pos[0]) == pos[0]) {\n    pos[0] += part.text.length;\n    return true;\n  } else if (predictive && part.text.indexOf(text.substring(pos[0])) == 0) {\n    // For predictive matching, if the remaining text is a prefix of the\n    // string literal pattern part, accept it as a match.\n    pos[0] += text.length - pos[0];\n    return true;\n  }\n  // We fall through to this point if the match fails\n  return false;\n};\n\n\n/**\n * Skip space in the string.\n *\n * @param {string} text input string.\n * @param {!Array<number>} pos where skip start, and return back where the skip\n *     stops.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.skipSpace_ = function(text, pos) {\n  'use strict';\n  const m = text.substring(pos[0]).match(/^\\s+/);\n  if (m) {\n    pos[0] += m[0].length;\n  }\n};\n\n\n/**\n * Parse an integer string and return integer value.\n *\n * @param {string} text string being parsed.\n * @param {!Array<number>} pos parse position.\n * @param {number} maxChars when > 0, at most this many characters are parsed.\n * @param {boolean=} allowSigned if true allows a single leading sign character\n *     (+|-) in the input. defaults to false\n *\n * @return {?number} integer value, or null if the integer cannot be parsed\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.parseInt_ = function(\n    text, pos, maxChars, allowSigned) {\n  'use strict';\n  text = maxChars > 0 ? text.substring(0, pos[0] + maxChars) : text;\n  allowSigned = allowSigned || false;\n  // Delocalizes the string containing native digits specified by the locale,\n  // replaces the native digits with ASCII digits. Leaves other characters.\n  // This is the reverse operation of localizeNumbers_ in datetimeformat.js.\n  if (this.dateTimeSymbols_.ZERODIGIT) {\n    const parts = [];\n    for (let i = pos[0]; i < text.length; i++) {\n      const c = text.charCodeAt(i) - this.dateTimeSymbols_.ZERODIGIT;\n      parts.push(\n          (0 <= c && c <= 9) ? String.fromCharCode(c + 0x30) : text.charAt(i));\n    }\n    text = parts.join('');\n  } else {\n    text = text.substring(pos[0]);\n  }\n\n  const signRe = allowSigned ? '[+-]?' : '';\n  const re = new RegExp(`^${signRe}\\\\d+`);\n  const m = text.match(re);\n  if (!m) {\n    return null;\n  }\n  pos[0] += m[0].length;\n  return parseInt(m[0], 10);\n};\n\n\n/**\n * Attempt to match the text at a given position against an array of strings.\n * Since multiple strings in the array may match (for example, if the array\n * contains \"a\", \"ab\", and \"abc\", all will match the input string \"abcd\") the\n * longest match is returned.\n *\n * @param {string} text The string to match to.\n * @param {!Array<number>} pos parsing position.\n * @param {!Array<string>} data The string array of matching patterns.\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {?number} the index of the best match in the array, or null\n *     indicating matching failure.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.matchString_ = function(\n    text, pos, data, predictive) {\n  'use strict';\n  // There may be multiple strings in the data[] array which begin with\n  // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).\n  // We keep track of the longest match, and return that. Note that this\n  // unfortunately requires us to test all array elements.\n  let bestMatchLength = 0;\n  let bestMatchIndex = null;\n  const lowerText = text.substring(pos[0]).toLowerCase();\n  for (let i = 0; i < data.length; i++) {\n    const lowerData = data[i].toLowerCase();\n    // For predictive parsing the first data string matching the remainder of\n    // the text is considered a match.\n    if (predictive && lowerData.indexOf(lowerText) == 0) {\n      bestMatchLength = lowerText.length;\n      bestMatchIndex = i;\n      break;\n    }\n    // Always compare if we have no match yet; otherwise only compare\n    // against potentially better matches (longer strings).\n    if (data[i].length > bestMatchLength && lowerText.indexOf(lowerData) == 0) {\n      bestMatchLength = data[i].length;\n      bestMatchIndex = i;\n    }\n  }\n  if (bestMatchIndex !== null) {\n    pos[0] += bestMatchLength;\n  }\n  return bestMatchIndex;\n};\n\n\n/**\n * Options object for calls to DateTimeParse.prototype.parse.\n * @record\n */\ngoog.i18n.DateTimeParse.ParseOptions = function() {\n  'use strict';\n  /**\n   * Whether to use predictive parsing. Predictive parsing generates successful\n   * parse results for non-empty partial inputs that have valid completions for\n   * the parse pattern.\n   *\n   * If the end of the input is reached while parsing, numeric patterns parts\n   * such as \"HH\" will infer values by padding with trailing 0s, and string\n   * pattern parts such as \"a\" will attempt to prefix match valid values. E.g.\n   * for the pattern \"HH:mm\" the input \"12:3\" will parse to a value equivalent\n   * to \"12:30\" and for the pattern \"h:mm a\" the input \"12:34 p\" will parse to\n   * a value equivalent to \"12:30 PM\".\n   *\n   * Predictive parsing currently only supports the pattern symbols \"ahHkKm\"\n   * and is not compatible with abutting number patterns. Attempting to parse\n   * using the predictive option with unsupported patterns will result in an\n   * error being thrown.\n   *\n   * defaults to false\n   * @type {boolean|undefined}\n   */\n  this.predictive;\n  /**\n   * Whether the parsed date/time value should be validated.\n   *\n   * Setting this to true is the equivalent of calling the now-deprecated\n   * DateTimeParse.prototype.strictParse.\n   *\n   * When true, parsing will fail if any of the parsed fields overflow, e.g.\n   * minutes > 60.\n   *\n   * defaults to false\n   * @type {boolean|undefined}\n   */\n  this.validate;\n};\n\n\n/**\n * This class hold the intermediate parsing result. After all fields are\n * consumed, final result will be resolved from this class.\n * @constructor\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_ = function() {};\n\n\n/**\n * The date's era.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.era;\n\n\n/**\n * The date's year.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.year;\n\n\n/**\n * The date's month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.month;\n\n\n/**\n * The date's day of month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.day;\n\n\n/**\n * The date's hour.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.hours;\n\n\n/**\n * The date's before/afternoon denominator.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.ampm;\n\n\n/**\n * The date's minutes.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.minutes;\n\n\n/**\n * The date's seconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.seconds;\n\n\n/**\n * The date's milliseconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.milliseconds;\n\n\n/**\n * The date's timezone offset.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.tzOffset;\n\n\n/**\n * The date's day of week. Sunday is 0, Saturday is 6.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.dayOfWeek;\n\n\n/**\n * Flag indicating if a provided two digit year needs to\n * be disambiguated\n *\n * @type {boolean}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.ambiguousYear = false;\n\n\n/**\n * 2 digit year special handling. Assuming for example that the\n * defaultCenturyStart is 6/18/1903. This means that two-digit years will be\n * forced into the range 6/18/1903 to 6/17/2003. As a result, years 00, 01, and\n * 02 correspond to 2000, 2001, and 2002. Years 04, 05, etc. correspond\n * to 1904, 1905, etc. If the year is 03, then it is 2003 if the\n * other fields specify a date before 6/18, or 1903 if they specify a\n * date afterwards. As a result, 03 is an ambiguous year. All other\n * two-digit years are unambiguous.\n *\n * @param {number} year 2 digit year value before adjustment.\n * @return {number} disambiguated year.\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_ = function(year) {\n  'use strict';\n  const now = new Date();\n  const defaultCenturyStartYear =\n      now.getFullYear() - goog.i18n.DateTimeParse.ambiguousYearCenturyStart;\n  const ambiguousTwoDigitYear = defaultCenturyStartYear % 100;\n  this.ambiguousYear = (year == ambiguousTwoDigitYear);\n  year += Math.floor(defaultCenturyStartYear / 100) * 100 +\n      (year < ambiguousTwoDigitYear ? 100 : 0);\n  return this.year = year;\n};\n\n\n/**\n * Based on the fields set, fill a Date object. For those fields that not\n * set, use the passed in date object's value.\n *\n * @param {?goog.date.DateLike} date Date object to be filled.\n * @param {boolean} validation If true, input date will be checked to make\n *     sure it is valid.\n *\n * @return {boolean} false if fields specify a invalid date.\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.calcDate_ = function(\n    date, validation) {\n  'use strict';\n  // Throw exception if date is null or undefined.\n  if (date == null) {\n    throw new Error('Parameter \\'date\\' should not be null.');\n  }\n\n  // year 0 is 1 BC, and so on.\n  if (this.era != undefined && this.year != undefined && this.era == 0 &&\n      this.year > 0) {\n    this.year = -(this.year - 1);\n  }\n\n  if (this.year != undefined) {\n    date.setFullYear(this.year);\n  }\n\n  // The setMonth and setDate logic is a little tricky. We need to make sure\n  // day of month is smaller enough so that it won't cause a month switch when\n  // setting month. For example, if data in date is Nov 30, when month is set\n  // to Feb, because there is no Feb 30, JS adjust it to Mar 2. So Feb 12 will\n  // become Mar 12.\n  const orgDate = date.getDate();\n\n  // Every month has a 1st day, this can actually be anything less than 29.\n  date.setDate(1);\n\n  if (this.month != undefined) {\n    date.setMonth(this.month);\n  }\n\n  if (this.day != undefined) {\n    date.setDate(this.day);\n  } else {\n    const maxDate =\n        goog.date.getNumberOfDaysInMonth(date.getFullYear(), date.getMonth());\n    date.setDate(orgDate > maxDate ? maxDate : orgDate);\n  }\n\n  if (typeof date.setHours === 'function') {\n    if (this.hours == undefined) {\n      this.hours = date.getHours();\n    }\n    // adjust ampm\n    if (this.ampm != undefined && this.ampm > 0 && this.hours < 12) {\n      this.hours += 12;\n    }\n    date.setHours(this.hours);\n  }\n\n  if (typeof date.setMinutes === 'function' && this.minutes != undefined) {\n    date.setMinutes(this.minutes);\n  }\n\n  if (typeof date.setSeconds === 'function' && this.seconds != undefined) {\n    date.setSeconds(this.seconds);\n  }\n\n  if (typeof date.setMilliseconds === 'function' &&\n      this.milliseconds != undefined) {\n    date.setMilliseconds(this.milliseconds);\n  }\n\n  // If validation is needed, verify that the uncalculated date fields\n  // match the calculated date fields.  We do this before we set the\n  // timezone offset, which will skew all of the dates.\n  //\n  // Don't need to check the day of week as it is guaranteed to be\n  // correct or return false below.\n  if (validation &&\n      (this.year && this.year != date.getFullYear() ||\n       this.month && this.month != date.getMonth() ||\n       this.day && this.day != date.getDate() ||\n       this.hours && this.hours >= 24 ||\n       this.minutes && this.minutes >= 60 ||\n       this.seconds && this.seconds >= 60 ||\n       this.milliseconds && this.milliseconds >= 1000)) {\n    return false;\n  }\n\n  // adjust time zone\n  if (this.tzOffset != undefined) {\n    const offset = date.getTimezoneOffset();\n    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);\n  }\n\n  // resolve ambiguous year if needed\n  if (this.ambiguousYear) {  // the two-digit year == the default start year\n    const defaultCenturyStart = new Date();\n    defaultCenturyStart.setFullYear(\n        defaultCenturyStart.getFullYear() -\n        goog.i18n.DateTimeParse.ambiguousYearCenturyStart);\n    if (date.getTime() < defaultCenturyStart.getTime()) {\n      date.setFullYear(defaultCenturyStart.getFullYear() + 100);\n    }\n  }\n\n  // dayOfWeek, validation only\n  if (this.dayOfWeek != undefined) {\n    if (this.day == undefined) {\n      // adjust to the nearest day of the week\n      let adjustment = (7 + this.dayOfWeek - date.getDay()) % 7;\n      if (adjustment > 3) {\n        adjustment -= 7;\n      }\n      const orgMonth = date.getMonth();\n      date.setDate(date.getDate() + adjustment);\n\n      // don't let it switch month\n      if (date.getMonth() != orgMonth) {\n        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));\n      }\n    } else if (this.dayOfWeek != date.getDay()) {\n      return false;\n    }\n  }\n  return true;\n};\n"],
"names":["goog","provide","require","requireType","i18n","DateTimeParse","PatternPart","goog.i18n.DateTimeParse","pattern","opt_dateTimeSymbols","asserts","assert","undefined","DateTimeSymbols","patternParts_","dateTimeSymbols_","applyStandardPattern_","applyPattern_","ambiguousYearCenturyStart","PATTERN_CHARS_","NUMERIC_FORMAT_CHARS_","PREDICTIVE_FORMAT_CHARS_","prototype","goog.i18n.DateTimeParse.prototype.applyPattern_","inQuote","buf","i","length","ch","charAt","push","text","count","abutStart","numeric","indexOf","getNextCharCount_","isNumericField_","markAbutStart_","goog.i18n.DateTimeParse.prototype.applyStandardPattern_","formatType","DateTimeFormat","Format","SHORT_DATETIME","MEDIUM_DATETIME","DATEFORMATS","TIMEFORMATS","DATETIMEFORMATS","replace","goog.i18n.DateTimeParse.prototype.getNextCharCount_","start","next","goog.i18n.DateTimeParse.prototype.markAbutStart_","abut","goog.i18n.DateTimeParse.prototype.isNumericField_","assertPatternSupportsPredictive_","goog.i18n.DateTimeParse.prototype.assertPatternSupportsPredictive_","part","Error","parse","goog.i18n.DateTimeParse.prototype.parse","date","options","predictive","validate","cal","MyDate_","parsePos","subParseLiteral_","partsParsed","subParseAbut_","subParse_","calcDate_","strictParse","goog.i18n.DateTimeParse.prototype.strictParse","goog.i18n.DateTimeParse.prototype.subParseAbut_","pos","abutPass","goog.i18n.DateTimeParse.prototype.subParse_","digitCount","skipSpace_","subParseString_","ERAS","value","era","subParseMonth_","weekdays","WEEKDAYS","SHORTWEEKDAYS","dayOfWeek","success","AMPMS","ampm","subParseYear_","quarters","QUARTERS","SHORTQUARTERS","month","day","subParseInt_","subParseFractionalSeconds_","hours","minutes","seconds","subParseTimeZoneInGMT_","goog.i18n.DateTimeParse.prototype.subParseYear_","parseInt_","setTwoDigitYear_","year","goog.i18n.DateTimeParse.prototype.subParseMonth_","months","MONTHS","STANDALONEMONTHS","SHORTMONTHS","STANDALONESHORTMONTHS","goog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_","len","milliseconds","Math","pow","round","goog.i18n.DateTimeParse.prototype.subParseTimeZoneInGMT_","tzOffset","offset","goog.i18n.DateTimeParse.prototype.subParseInt_","maxChars","callback","goog.i18n.DateTimeParse.prototype.subParseString_","data","matchString_","goog.i18n.DateTimeParse.prototype.subParseLiteral_","substring","goog.i18n.DateTimeParse.prototype.skipSpace_","m","match","goog.i18n.DateTimeParse.prototype.parseInt_","allowSigned","ZERODIGIT","parts","c","charCodeAt","String","fromCharCode","join","signRe","re","RegExp","parseInt","goog.i18n.DateTimeParse.prototype.matchString_","bestMatchLength","bestMatchIndex","lowerText","toLowerCase","lowerData","ParseOptions","goog.i18n.DateTimeParse.ParseOptions","goog.i18n.DateTimeParse.MyDate_","ambiguousYear","goog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_","now","Date","defaultCenturyStartYear","getFullYear","ambiguousTwoDigitYear","floor","goog.i18n.DateTimeParse.MyDate_.prototype.calcDate_","validation","setFullYear","orgDate","getDate","setDate","setMonth","maxDate","getNumberOfDaysInMonth","getMonth","setHours","getHours","setMinutes","setSeconds","setMilliseconds","getTimezoneOffset","setTime","getTime","defaultCenturyStart","adjustment","getDay","orgMonth"]
}

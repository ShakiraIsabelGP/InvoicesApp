{"version":3,"sources":["com/wsscode/common/combinatorics.cljc"],"mappings":";AAEA,AAAA;;;qDAAA,6DAAAA,lHAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,wFAAAF;;;AAAA,AAAA,CAAA,0FAAA,1FAAME,qGAEDI;AAFL,AAGE,IAAMC,kBAAgB,AAACC,cAAIF;IACrBG,OACA,gDAAUC;AAAV,AACE,IAAMC,YACA,WAAKD;AAAL,AACE,IAAOE,IAAE,+BAAA,9BAAK,AAACC,gBAAMH;IAAUA,aAAOA;;AAAtC,AACE,GAAI,+CAAA,/CAACI,6CAAEF;AAAP;;AACI,IAAAG,qBAAa,AAACE,eAAK,CAACP,2CAAAA,8CAAAA,LAAOE,0BAAAA;AAA3B,AAAA,GAAAG;AAAA,UAAAA,NAASC;AAAT,AACE,OAACE,8CAAMR,WAAOE,EAAEI;;AAChB,eAAO,KAAA,JAAKJ;eAAG,AAACM,8CAAMR,WAAOE,EAAE,CAACL,gDAAAA,mDAAAA,LAAgBK,+BAAAA;;;;;;;;;AANhE,AAOE,oBAAMF;AAAN,AACE,OAACS,eAAK,AAACC,4CAAIC,gBAAMX,QACX,KAAAY,kBAAA,KAAA;AAAA,AAAU,OAACb,sCAAK,AAACE,UAAUD;GAA3B,KAAA;;AAFR;;;AAVV,AAaE,GAAM,AAACa,uBAAOlB,cAAIC;AAAlB,AACE,YAAAgB,kBAAA,KAAA;AAAA,AAAU,OAACb,KAAKF;GAAhB,KAAA;;AADF;;;;AAhBJ,CAAA,6EAAA,7EAAML;;AAAN;AAAA,CAAA,uEAAA,WAAAC,lFAAMD;AAAN,AAAA,IAAAE,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAF;;;AAAA","names":["var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","com.wsscode.common.combinatorics/cartesian-product","seq53770","self__5755__auto__","cljs.core/seq","seqs","v-original-seqs","cljs.core/vec","step","v-seqs","increment","i","cljs.core/count","cljs.core._EQ_","temp__5802__auto__","rst","cljs.core/next","cljs.core.assoc","cljs.core/cons","cljs.core.map","cljs.core/first","cljs.core/LazySeq","cljs.core/every?"],"sourcesContent":["(ns com.wsscode.common.combinatorics)\n\n(defn cartesian-product\n  \"All the ways to take one item from each sequence\"\n  [& seqs]\n  (let [v-original-seqs (vec seqs)\n        step\n        (fn step [v-seqs]\n          (let [increment\n                (fn [v-seqs]\n                  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                    (if (= i -1) nil\n                        (if-let [rst (next (v-seqs i))]\n                          (assoc v-seqs i rst)\n                          (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n            (when v-seqs\n              (cons (map first v-seqs)\n                    (lazy-seq (step (increment v-seqs)))))))]\n    (when (every? seq seqs)\n      (lazy-seq (step v-original-seqs)))))\n"]}
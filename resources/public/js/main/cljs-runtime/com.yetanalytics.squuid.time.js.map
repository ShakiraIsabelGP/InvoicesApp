{"version":3,"sources":["com/yetanalytics/squuid/time.cljc"],"mappings":";AAGA,AAAeA,6CACb,CAAA,+CAAA;AAGF;;;2CAAA,3CAAKC;AAIL;;;;AAAKC,yCAIM,KAAAC,KAAA;AAEX;;;4CAAA,5CAAMC;AAAN,AAGE,IAAMC,eACsB,AAAMF;AADlC,AAEE,GAAQ,CAAIE,gBAAaJ;AAAzB;AAAA,AAAA,MAAA,KAAAK,MAAA,CAAA,6DAAA,KAAA,hDACQN;;;AAEC,YAAAG,KAAUE;;AAEvB;;;6CAAA,7CAAME,kGAGOC,MAAMC;AAHnB,AAG0B,QAAGD,QAAMC","names":["com.yetanalytics.squuid.time/max-time-emsg","com.yetanalytics.squuid.time/max-seconds","com.yetanalytics.squuid.time/zero-time","js/Date","com.yetanalytics.squuid.time/current-time","curr-seconds","js/Error","com.yetanalytics.squuid.time/before?","time1","time2"],"sourcesContent":["(ns com.yetanalytics.squuid.time\n  #?(:clj (:import [java.time Instant])))\n\n(def ^:private max-time-emsg\n  (str \"Cannot generate SQUUID past August 2, 10889.\"\n       \" The timestamp would have exceeded 48 bits.\"))\n\n(def max-seconds\n  \"The maximum underlying value of a 48-bit timestamp.\"\n  0x0000FFFFFFFFFFFF)\n\n(def zero-time\n  \"Return the timestamp corresponding to the beginning of the UNIX epoch,\n   on Jan 1, 1970.\"\n  #?(:clj Instant/EPOCH\n     :cljs (js/Date. 0)))\n\n(defn current-time\n  \"Return the timestamp corresponding to the current system time.\"\n  []\n  (let [curr-seconds #?(:clj (System/currentTimeMillis)\n                        :cljs (.now js/Date))]\n    (assert (<= curr-seconds max-seconds)\n            max-time-emsg)\n    #?(:clj (Instant/ofEpochMilli curr-seconds)\n       :cljs (js/Date. curr-seconds))))\n\n(defn before?\n  \"Does `time1` occur strictly before `time2`?\"\n  #?(:clj ([^Instant time1 ^Instant time2] (.isBefore time1 time2))\n     :cljs ([time1 time2] (< time1 time2))))\n\n#?(:clj\n   (defn ms->Instant\n     \"Convenience function returning a java.time.Instant object \n      given `ms` from the beginning of the UNIX epoch.\"\n     [ms]\n     (Instant/ofEpochMilli ms)))\n"]}
{"version":3,"sources":["com/yetanalytics/squuid/uuid.cljc"],"mappings":"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","names":["com.yetanalytics.squuid.uuid/bit-mask-16","js/BigInt","com.yetanalytics.squuid.uuid/bit-shift-16","com.yetanalytics.squuid.uuid/zero-uuid","com.yetanalytics.squuid.uuid/rand-uuid","cljs.core/random-uuid","com.yetanalytics.squuid.uuid/compare-uuid","u1","u2","cljs.core._EQ_","com.yetanalytics.squuid.uuid/extract-ts-bytes","uuid","s","cljs.core.subs","js/parseInt","com.yetanalytics.squuid.uuid/throw-inc-uuid-error","u","cljs.core.ex_info","com.yetanalytics.squuid.uuid/throw-neg-timestamp","ts","com.yetanalytics.squuid.uuid/ts->num","ts-num","cljs.core/inst-ms","cljs.core/nat-int?","com.yetanalytics.squuid.uuid/inc-uuid","u-char-arr","js/Array.from","inc-char","c","ret-uuid","char-arr","cljs.core/UUID","clojure.string.join","i","fexpr__83932","var_args","G__83934","com.yetanalytics.squuid.uuid/make-squuid","js/Error","com.yetanalytics.squuid.uuid.make_squuid","make-padding","max-len","cljs.core.repeat","cljs.core/count","ts'","ts-hi","ts-lo","ts-hs","ts-ls","ts-hp","ts-lp","u-str","raw-squuid","cooked-squuid"],"sourcesContent":["(ns com.yetanalytics.squuid.uuid\n  #?(:clj (:import [java.util UUID])\n     :cljs (:require [clojure.string :refer [join]])))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Private constants\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (def ^{:private true :const true} bit-mask-12\n     (unchecked-long 0x0000000000000FFF)))\n\n#?(:clj\n   (def ^{:private true :const true} bit-mask-16\n     (unchecked-long 0x000000000000FFFF)))\n\n#?(:clj\n   (def ^{:private true :const true} min-uuid-lsb\n     (unchecked-long 0x8000000000000000)))\n\n#?(:clj\n   (def ^{:private true :const true} max-uuid-lsb\n     (unchecked-long 0xBFFFFFFFFFFFFFFF)))\n\n#?(:cljs\n   (def ^:private bit-mask-16 (js/BigInt 0xFFFF)))\n\n#?(:cljs\n   (def ^:private bit-shift-16 (js/BigInt 16)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Helper vars and functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def zero-uuid\n  \"The v0 UUID of all zeroes.\"\n  #uuid \"00000000-0000-0000-0000-000000000000\")\n\n(defn rand-uuid\n  \"Generate a random v4 UUID.\"\n  []\n  #?(:clj (UUID/randomUUID)\n     :cljs (random-uuid)))\n\n(defn compare-uuid\n  \"Returns:\n   - (< uuid1 uuid2): -1\n   - (= uuid1 uuid2): 0\n   - (> uuid1 uuid2): 1\"\n  [^UUID u1 ^UUID u2]\n  #?(:clj\n     (.compareTo u1 u2)\n     :cljs\n     (let [u1 (.toString u1)\n           u2 (.toString u2)]\n       (cond\n         (< u1 u2) -1\n         (= u1 u2) 0\n         (> u1 u2) 1))))\n\n(defn extract-ts-bytes\n  \"Extracts the first 48 bits of a SQUUID corresponding to a timestamp.\"\n  [^UUID uuid]\n  #?(:clj\n     (-> (.getMostSignificantBits uuid)\n         (bit-shift-right 16))\n     :cljs\n     (let [s (str uuid)]\n       (-> (str (subs s 0 8) (subs s 9 13))\n           (js/parseInt 16)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Private helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- throw-inc-uuid-error\n  [u]\n  (throw (ex-info (str \"Cannot increment UUID \" u \" any further.\")\n                  {:type ::exceeded-max-uuid-node\n                   :uuid u})))\n\n(defn- throw-neg-timestamp\n  [ts]\n  (throw (ex-info (str \"Timestamp \" ts \" occurs before January 1, 1970\")\n                  {:type ::negative-timestamp\n                   :time ts})))\n\n(defn- ts->num\n  [ts]\n  (let [ts-num (inst-ms ts)]\n    (when-not (nat-int? ts-num) (throw-neg-timestamp ts))\n    ts-num))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Major functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn inc-uuid\n  \"Increment the UUID by one bit. Throws an exception if there are no available\n   bits left to increment.\"\n  [^UUID u]\n  #?(:clj ; Use bit operations\n     (let [uuid-msb (.getMostSignificantBits u)\n           uuid-lsb (.getLeastSignificantBits u)]\n       (cond\n         ;; least significant bits not maxed out\n         ;; (Note that `<` isn't used since Java doesn't have unsigned ints)\n         (not= uuid-lsb max-uuid-lsb)\n         (UUID. uuid-msb (inc uuid-lsb))\n         ;; most significant bits not maxed out\n         (not= (bit-and bit-mask-12 uuid-msb) bit-mask-12)\n         (UUID. (inc uuid-msb) min-uuid-lsb)\n         ;; oh no\n         :else\n         (throw-inc-uuid-error u)))\n\n     :cljs ; Use string operations\n     (let [u-char-arr (js/Array.from (.toString u))\n           inc-char   (fn [c] (.toString (inc (js/parseInt c 16)) 16))\n           ret-uuid   (fn [char-arr] (UUID. (join char-arr) nil))]\n       (loop [i 35] ; start from the back and inch forwards\n         (cond\n           ;; Regular hexes: 0x0 to 0xF\n           (or (< 23 i)\n               (< 19 i 23)\n               (< 14 i 18))\n           (let [c (aget u-char-arr i)]\n             (if (or (identical? \"F\" c) (identical? \"f\" c))\n               (do (aset u-char-arr i \"0\")\n                   (recur (dec i)))\n               (do (aset u-char-arr i (inc-char c))\n                   (ret-uuid u-char-arr))))\n\n           ;; Variant hexes: 0x0 to 0xB\n           (= 19 i)\n           (let [c (aget u-char-arr i)]\n             (if (or (identical? \"B\" c) (identical? \"b\" c))\n               (do (aset u-char-arr i \"8\")\n                   (recur (dec i)))\n               (do (aset u-char-arr i (inc-char c))\n                   (ret-uuid u-char-arr))))\n\n           ;; Dashes: ignore\n           (#{18 23} i)\n           (recur (dec i))\n\n           :else\n           (throw-inc-uuid-error u))))))\n\n(defn make-squuid\n  \"Make a new v8 sequential UUID. Uses `uuid` as the base UUID if provided;\n   otherwise uses a random v4 UUID as the base. Returns a map containing\n   `:base-uuid` and `:squuid`.\"\n  ([ts]\n   (make-squuid ts (rand-uuid)))\n  ([ts ^UUID u]\n   #?(:clj ; Use bit operations\n      (let [;; Timestamp\n            ts-long   (ts->num ts)\n            ;; Base UUID\n            uuid-msb  (.getMostSignificantBits u)\n            uuid-lsb  (.getLeastSignificantBits u)\n            ;; Putting it all together (and change version from v4 to v8)\n            uuid-msb' (-> (bit-or (bit-shift-left ts-long 16)\n                                  (bit-and bit-mask-16 uuid-msb))\n                          (bit-clear 14)\n                          (bit-set 15))\n            squuid    (UUID. uuid-msb' uuid-lsb)]\n        {:base-uuid u\n         :squuid    squuid})\n\n      :cljs ; Use string operations\n      (let [make-padding\n            (fn [max-len s] (join (repeat (- max-len (count s)) \"0\")))\n            ;; Timestamp manips\n            ts'   (js/BigInt (ts->num ts))\n            ts-hi (bit-shift-right ts' bit-shift-16)\n            ts-lo (bit-and ts' bit-mask-16)\n            ts-hs (.toString ts-hi 16)\n            ts-ls (.toString ts-lo 16)\n            ts-hp (make-padding 8 ts-hs)\n            ts-lp (make-padding 4 ts-ls)\n            ;; Base UUID manips\n            u-str (subs (.toString u) 15)\n            ;; Cook some SQUUID\n            raw-squuid    (str ts-hp ts-hs\n                               \"-\"\n                               ts-lp ts-ls\n                               \"-\"\n                               \"8\" u-str)\n            cooked-squuid (UUID. raw-squuid nil)]\n        {:base-uuid u\n         :squuid    cooked-squuid}))))\n"]}
{"version":3,"sources":["com/fulcrologic/rad/type_support/js_date_formatter.cljs"],"mappings":"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","names":["com.fulcrologic.rad.type-support.js-date-formatter/tokenize","format-str","add-token","p__87070","map__87071","cljs.core/--destructure-map","cljs.core.get","literal?","letters","acc","cljs.core/seq","cljs.core.update","cljs.core/conj","G__87072","clojure.string.join","cljs.core/PersistentArrayMap","cljs.core.reduce","p__87073","map__87074","prior-letter","letter","cljs.core._EQ_","cljs.core.assoc","and__5043__auto__","p__87075","map__87076","com.fulcrologic.rad.type-support.js-date-formatter/std-formatter","zero-pad?","options","zero-pad","s","cljs.core/count","locale-name","zone-name","formatter","js/Intl.DateTimeFormat","cljs.core/clj->js","cljs.core.merge","cljs.core.dissoc","inst","G__87077","com.fulcrologic.rad.type-support.js-date-formatter/zone-name-formatter","format","cljs.core/last","clojure.string.split","com.fulcrologic.rad.type-support.js-date-formatter/seconds->zone-offset","totalSeconds","size","absTotalSeconds","Math/abs","absSeconds","cljs.core/mod","absHours","absMinutes","sign","hours","mins","secs","G__87078","com.fulcrologic.rad.type-support.js-date-formatter/zone-offset-formatter","_","z","cljc.java_time.zone_id.of","i","cljc.java-time.instant/of-epoch-milli","cljs.core/inst-ms","or__5045__auto__","js/Date","offset","cljc.java-time.zoned-date-time/get-offset","cljc.java_time.zoned_date_time.of_instant","cljc.java-time.zone-offset/get-total-seconds","com.fulcrologic.rad.type-support.js-date-formatter/format-map","G__87079","cljs.core/re-matches","cljs.core/second","clojure.string/trim","com.fulcrologic.rad.type-support.js-date-formatter/new-formatter","tokens","generator","token","cljs.core/map?","cljs.core/constantly","f","generators","cljs.core.mapv","cljs.core.map","gen"],"sourcesContent":["(ns com.fulcrologic.rad.type-support.js-date-formatter\n  \"An implementation of date formatting that uses ISO format specifiers, but uses browser built-in Intl support\n   to get the locale-dependent values\"\n  (:require\n    [clojure.string :as str]\n    [cljc.java-time.zoned-date-time :as zdt]\n    [taoensso.timbre :as log]\n    [cljc.java-time.zone-id :as zone-id]\n    [cljc.java-time.zone-offset :as zo]\n    [cljc.java-time.instant :as instant]))\n\n(def tokenize\n  \"[format-str]\n\n   Turns a string that has repeating characters into groups of those repeating letters. This function is memoized, so\n   it is best to ONLY use it on date/time format patterns, of which there will likely be few.\"\n  (fn [format-str]\n    (let [add-token (fn [{:keys [literal? letters] :as acc}]\n                      (if (seq letters)\n                        (update acc :tokens conj (cond->> (str/join letters)\n                                                   literal? (array-map :literal)))\n                        acc))\n          acc       (let [letters (seq format-str)]\n                      (reduce\n                        (fn [{:keys [literal? prior-letter] :as acc} letter]\n                          (cond\n                            (and (= \\' letter) (= \\' prior-letter)) (-> acc\n                                                                      (assoc :literal? false\n                                                                             :letters []\n                                                                             :prior-letter \"\")\n                                                                      (update :tokens conj {:literal \\'}))\n                            (and literal? (= \\' letter)) (-> acc\n                                                           (add-token)\n                                                           (assoc :literal? false :letters [] :prior-letter \"\"))\n                            (= \\' letter) (-> acc\n                                            (add-token)\n                                            (assoc :literal? true :letters [] :prior-letter \\'))\n\n                            literal? (-> acc\n                                       (assoc :prior-letter letter)\n                                       (update :letters conj letter))\n\n                            (= prior-letter letter) (update acc :letters conj letter)\n                            :else (-> acc\n                                    (add-token)\n                                    (assoc :prior-letter letter)\n                                    (assoc :letters [letter]))))\n                        {:tokens       []\n                         :literal?     false\n                         :letters      []\n                         :prior-letter nil}\n                        letters))]\n      (-> acc\n        (add-token)\n        :tokens))))\n\n(defn- std-formatter [{:keys [zero-pad?] :as options}]\n  (let [zero-pad (fn [s] (if (= 1 (count s))\n                           (str \"0\" s)\n                           s))]\n    (fn [locale-name zone-name]\n      (let [formatter (js/Intl.DateTimeFormat. locale-name (clj->js (merge {:timeZone zone-name}\n                                                                      (dissoc options :zero-pad?))))]\n        (fn [inst]\n          (cond-> (.format formatter inst)\n            zero-pad? zero-pad))))))\n\n(defn- zone-name-formatter [format]\n  (fn [locale-name zone-name]\n    (let [formatter (js/Intl.DateTimeFormat. locale-name #js {:timeZone     zone-name\n                                                              :timeZoneName format\n                                                              :minute       \"numeric\"})]\n      (fn [inst]\n        (last (str/split (.format formatter inst) #\"\\s+\"))))))\n\n(defn- seconds->zone-offset [^long totalSeconds size]\n  (let [absTotalSeconds (int (Math/abs totalSeconds))\n        absSeconds      (int (mod absTotalSeconds 60))      ;\n        absHours        (int (/ absTotalSeconds 3600))\n        absMinutes      (int (mod (/ absTotalSeconds 60) 60))\n        sign            (if (neg? totalSeconds) \"-\" \"+\")\n        hours           (str (if (< absHours 10) \"0\" \"\") absHours)\n        mins            (str (if (< absMinutes 10) \"0\" \"\") absMinutes)\n        secs            (str (if (< absSeconds 10) \"0\" \"\") absSeconds)]\n    (if (zero? totalSeconds)\n      \"Z\"\n      (case size\n        1 (str sign hours (when (pos? absMinutes) mins))\n        2 (str sign hours mins)\n        3 (str sign hours \":\" mins)\n        4 (str sign hours mins (when (pos? absSeconds) secs))\n        5 (str sign hours \":\" mins (when (pos? absSeconds) (str \":\" secs)))\n        nil))))\n\n(defn- zone-offset-formatter [size]\n  (fn [_ zone-name]\n    (let []\n      (fn [inst]\n        (let [z      (zone-id/of zone-name)\n              i      (instant/of-epoch-milli (inst-ms (or inst (js/Date.))))\n              offset (zdt/get-offset (zdt/of-instant i z))]\n          (seconds->zone-offset (zo/get-total-seconds offset) size))))))\n\n(def format-map\n  {\"a\"     (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"numeric\"})]\n               (fn [inst]\n                 (or\n                   (some-> (re-matches #\"^\\d+(.*)$\" (.format formatter inst)) (second) (str/trim))\n                   \"\"))))\n   ;; If you don't include some element of time, then zone name includes the whole darn date :(\n   \"Z\"     (zone-name-formatter \"short\")\n   \"ZZ\"    (zone-name-formatter \"short\")\n   \"ZZZ\"   (zone-name-formatter \"short\")\n   \"ZZZZ\"  (zone-name-formatter \"long\")\n   \"X\"     (zone-offset-formatter 1)\n   \"XX\"    (zone-offset-formatter 2)\n   \"XXX\"   (zone-offset-formatter 3)\n   \"XXXX\"  (zone-offset-formatter 4)\n   \"XXXXX\" (zone-offset-formatter 5)\n   \"M\"     (std-formatter {:month \"numeric\"})\n   \"MM\"    (std-formatter {:month \"2-digit\"})\n   \"MMM\"   (std-formatter {:month \"short\"})\n   \"MMMM\"  (std-formatter {:month \"long\"})\n   \"MMMMM\" (std-formatter {:month \"narrow\"})\n   \"m\"     (std-formatter {:minute \"numeric\"})\n   \"mm\"    (std-formatter {:minute \"numeric\" :zero-pad? true})\n   \"d\"     (std-formatter {:day \"numeric\"})\n   \"dd\"    (std-formatter {:day \"numeric\" :zero-pad? true})\n   \"h\"     (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"numeric\"})]\n               (fn [inst]\n                 (second (re-matches #\"^(\\d+).*$\" (.format formatter inst))))))\n   \"hh\"    (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"2-digit\"})]\n               (fn [inst]\n                 (second (re-matches #\"^(\\d+).*$\" (.format formatter inst))))))\n   \"H\"     (std-formatter {:hour12 false :hour \"numeric\"})\n   \"HH\"    (std-formatter {:hour12 false :hour \"2-digit\"})\n   \"y\"     (std-formatter {:year \"numeric\"})\n   \"yy\"    (std-formatter {:year \"2-digit\"})\n   \"yyy\"   (std-formatter {:year \"numeric\"})\n   \"yyyy\"  (std-formatter {:year \"numeric\"})\n   \"E\"     (std-formatter {:weekday \"short\"})\n   \"EE\"    (std-formatter {:weekday \"long\"})\n   \"EEE\"   (std-formatter {:weekday \"narrow\"})\n   \"s\"     (std-formatter {:second \"numeric\"})\n   \"ss\"    (std-formatter {:second \"numeric\" :zero-pad? true})})\n\n(defn new-formatter\n  \"Build a formatter. Returns a `(fn [inst] string?)`.\"\n  [format-str locale-name zone-name]\n  (let [tokens     (tokenize format-str)\n        generator  (fn [token]\n                     (if (map? token)\n                       (constantly (:literal token))\n                       (let [f (get format-map token)]\n                         (if f\n                           (f locale-name zone-name)\n                           (constantly token)))))\n        generators (mapv generator tokens)]\n    (fn [inst] (str/join (map (fn [gen] (gen inst)) generators)))))\n"]}